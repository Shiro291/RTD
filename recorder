if game.PlaceId ~= 124069847780670 then return end

local replicatedstorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local library = loadstring(game:HttpGet('https://raw.githubusercontent.com/Shiro291/RTD/refs/heads/main/library'))()

local teamwork = replicatedstorage.Teawork
local client = teamwork.Client
local sharedd = teamwork.Shared

local bytenet = require(sharedd.Services.ByteNetworking)
local modifiersmodule = require(client.Services.Game.ModifierController)
local datamodule = require(client.Services.DataSync)

local towers = bytenet.Towers
local mapinfo = replicatedstorage.RoundInfo

local ostime = os.time
local concat = table.concat
local taskwait = task.wait

local equippedtowers = datamodule:Get().EquippedTowers

getgenv().StratName = "Strat"

getgenv().timer = 0 -- seconds
getgenv().wave = mapinfo:GetAttribute("Wave")

getgenv().map = mapinfo:GetAttribute("Map")
getgenv().modifiers = modifiersmodule.GetModifiers()

getgenv().plrtowers = {}

getgenv().destroyui = false

getgenv().temp = {modifiers = {}, towers = {}}
getgenv().hooks = {}
getgenv().recorded_events = {} -- Buffer for events

for i = 1, #modifiers do
	temp.modifiers[i] = `'{modifiers[i]}'`
end

for i, v in equippedtowers do
	table.insert(temp.towers, `'{v}'`)
end

local window = library:CreateWindow({
    Title = "Shitty X",
    Size = UDim2.new(0, 350, 0, 370),
    Position = UDim2.new(0.5, 0, 0, 70),
    NoResize = false
})

window:Center()

local modifiers_str = `\{{concat(temp.modifiers, ", ")}\}`
local plrtowers_str = `\{{concat(temp.towers, ", ")}\}`

temp = nil

local filetab = window:CreateTab({
    Name = "Recorder",
    Visible = true
})

local filename = filetab:Label({
    Text = "StratName: " .. getgenv().StratName
})

local textbox = filetab:InputText({
    Label = "",
    PlaceHolder = "Enter Name: ",
    Callback = function(text)
        getgenv().StratName = text.Value
        filename:SetText("StratName: " .. text.Value)
    end
})

local writebutton = filetab:Button({
  	Text = "Write File",
    	Callback = function()
    		-- Use readfile for api.lua, but fallback to original URL if readfile fails or file missing
    		-- Actually better to assume user has it or provide instructions.
    		-- For now, we write a script that tries to load local, else remote (but we don't have remote yet).
    		-- We'll point to local file 'RTD/api.lua' as requested.
    		local content = "local api = loadstring(readfile('RTD/api.lua'))()\n\n" .. 
    			`api:Loadout({plrtowers_str})\n` ..
    			`api:Map('{map}', {modifiers_str})\n\n` ..
    			"api:Start()\n\n" ..
    			"api:Loop(function()\n"

    		-- Process recorded events
    		if #recorded_events > 0 then
    			-- Find the first time-sensitive event to establish t=0
    			-- Difficulty vote usually happens first but might not be time sensitive?
    			-- Actually, the user wants "instant place".
    			-- Let's find the time of the first event that IS NOT Difficulty (if Difficulty has t=0)
    			-- Or just take the first event's time.
    			
    			local start_time = 0
    			for _, event in ipairs(recorded_events) do
    				if event.time > 0 then
    					start_time = event.time
    					break
    				end
    			end
    			
    			-- If the very first event is at 34s, start_time = 34.
    			-- Then 34 becomes 0.
    			
    			for _, event in ipairs(recorded_events) do
    			    -- Normalize time: subtract start_time so first event is at 0
    				local normalized_time = math.max(0, event.time - start_time)
    				-- Keep 2 decimal precision for cleaner files
    				normalized_time = math.floor(normalized_time * 100) / 100
    				
    				if event.type == "Difficulty" then
    					content = content .. `\t api:Difficulty('{event.args[1]}')\n`
    				elseif event.type == "Place" then
    					-- Use 3 decimal places for position to keep it clean but accurate
    					content = content .. `\t api:Place('{event.args[1]}', Vector3.new({event.args[2]}), {normalized_time}, {event.wave})\n`
    				elseif event.type == "Upgrade" then
    					content = content .. `\t api:Upgrade({event.args[1]}, {normalized_time}, {event.wave})\n`
    				elseif event.type == "Sell" then
    					content = content .. `\t api:Sell({event.args[1]}, {normalized_time}, {event.wave})\n`
    				elseif event.type == "Target" then
    					content = content .. `\t api:SetTarget({event.args[1]}, '{event.args[2]}', {normalized_time}, {event.wave})\n`
    				elseif event.type == "Ready" then
    					content = content .. `\t api:Ready({normalized_time}, {event.wave})\n`
    				elseif event.type == "Skip" then
    					content = content .. `\t api:Skip({normalized_time}, {event.wave})\n`
    				elseif event.type == "AutoSkip" then
    					content = content .. `\t api:AutoSkip({event.args[1]}, {normalized_time}, {event.wave})\n`
    				elseif event.type == "PlayAgain" then
    					content = content .. `\t api:PlayAgain()\n`
    				end
    			end
    		end

    		content = content .. " end)"
    		
   		    writefile(getgenv().StratName .. '.lua', content)
        	
        	getgenv().destroyui = true
 	end
})

while not destroyui do
    taskwait(0.1)
end

writebutton:Destroy()
textbox:Destroy()

taskwait(1)

local recordertab = filetab
local logstab = window:CreateTab({
    Name = "Logs",
    Visible = true
})

local loglabel = recordertab:Label({
    Label = "Last Log: Voting"
})

local row = logstab:Row()

logstab:Separator({
	Text = "Logs:"
})

local logs = logstab:Console({
	Text = "",
	ReadOnly = true,
	LineNumbers = false,
	Border = false,
	Fill = true,
	Enabled = true,
	AutoScroll = true,
	RichText = true,
	MaxLines = 200
})


function updatelog(text: string)
	setthreadidentity(7)
	logs:AppendText(DateTime.now():FormatLocalTime("HH:mm:ss", "en-us") .. ":", text)
	loglabel:SetText("Last Log: " .. text)
end

window:ShowTab(recordertab)
updatelog("Voting")

while #mapinfo:GetAttribute("Difficulty") == 0 do
  	taskwait(0.05)
end 

-- Use Heartbeat for recorder timer as well to match player
local TimerConnection = RunService.Heartbeat:Connect(function(dt)
	-- Assuming 2x speed for recorder view, but actual game time is better?
	-- The original used (ostime - lasttime)*2
	-- We should stick to *2 if that's the game rule
	timer = timer + (dt * 2)
end)

updatelog("Game Started")

-- We handle Difficulty separately as it often resets the timer in the player script
-- But for recording, we just log it.
-- In the player script, api:Difficulty resets timer to 0.
-- So we should probably capture Difficulty as event but NOT offset its time?
-- Actually, the player script calls Difficulty inside the loop.
-- Let's just record it.

mapinfo:GetAttributeChangedSignal("Wave"):Connect(function()
	wave = mapinfo:GetAttribute("Wave")
end)

-- Helper to record
local function RecordEvent(type, args)
	table.insert(recorded_events, {
		type = type,
		args = args,
		time = timer,
		wave = wave
	})
end

-- We need to capture Difficulty explicitly? 
-- The original code wrote it immediately: appendfile(..., `\t api:Difficulty('{mapinfo:GetAttribute("Difficulty")}')\n`)
RecordEvent("Difficulty", {mapinfo:GetAttribute("Difficulty")})

-- Main Record Macros
bytenet.RoundResult.Show.listen(function() -- end screen
	updatelog("Macro Recorded!")
	RecordEvent("PlayAgain", {})
	if TimerConnection then TimerConnection:Disconnect() end
end)

hooks["ready"] = hookfunction(bytenet.ReadyVote.Vote.send, function(value)
	if checkcaller() then return hooks["ready"](value) end

	updatelog("Sent ready vote")
	RecordEvent("Ready", {})
	return hooks["ready"](value)
end)

hooks["skip"] = hookfunction(bytenet.SkipWave.Vote.send, function(value)
	if checkcaller() then return hooks["skip"](value) end

	updatelog("Skipped Wave " .. wave)
	RecordEvent("Skip", {})
	return hooks["skip"](value)
end)

hooks["autoskip"] = hookfunction(bytenet.SkipWave.ToggleAutoSkip.send, function(value)
	if checkcaller() then return hooks["autoskip"](value) end

	updatelog("AutoSkip set to: " .. tostring(value))
	RecordEvent("AutoSkip", {value})
	return hooks["autoskip"](value)
end)

hooks["place"] = hookfunction(towers.PlaceTower.invoke, function(towerdata)	
	if checkcaller() then return hooks["place"](towerdata) end

	updatelog(`Placed Tower {towerdata.TowerID}`)
	-- Vector3 to string format: x, y, z
	local pos = towerdata.Position
	local posStr = `{pos.X}, {pos.Y}, {pos.Z}`
	RecordEvent("Place", {towerdata.TowerID, posStr})
	
	return hooks["place"](towerdata)
end)

hooks["upgrade"] = hookfunction(towers.UpgradeTower.invoke, function(index)
	if checkcaller() then return hooks["upgrade"](index) end

	updatelog("Upgraded Tower " .. index)
	RecordEvent("Upgrade", {index})
	return hooks["upgrade"](index)
end)

hooks["target"] = hookfunction(towers.SetTargetMode.send, function(towerdata)
	if checkcaller() then return hooks["target"](towerdata) end

	updatelog(`Changed Tower {towerdata.UID} Target to {towerdata.TargetMode} `)
	RecordEvent("Target", {towerdata.UID, towerdata.TargetMode})
	return hooks["target"](towerdata)
end)

hooks["sell"] = hookfunction(towers.SellTower.invoke, function(index)
	if checkcaller() then return hooks["sell"](index) end

	updatelog("Sold Tower " .. index)
	RecordEvent("Sell", {index})
	return hooks["sell"](index)
end)
