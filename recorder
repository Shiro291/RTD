if game.PlaceId ~= 124069847780670 then return end

local replicatedstorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

-- Use user's preferred library
local library = loadstring(game:HttpGet('https://raw.githubusercontent.com/Shiro291/RTD/refs/heads/main/library'))()

local teamwork = replicatedstorage.Teawork
local client = teamwork.Client
local sharedd = teamwork.Shared

local bytenet = require(sharedd.Services.ByteNetworking)
local modifiersmodule = require(client.Services.Game.ModifierController)
local datamodule = require(client.Services.DataSync)

local towers = bytenet.Towers
local mapinfo = replicatedstorage.RoundInfo

local ostime = os.time
local concat = table.concat
local taskwait = task.wait

local equippedtowers = datamodule:Get().EquippedTowers

getgenv().StratName = "Strat"
getgenv().timer = 0
getgenv().wave = mapinfo:GetAttribute("Wave") or 1
getgenv().map = mapinfo:GetAttribute("Map")
getgenv().modifiers = modifiersmodule.GetModifiers()
getgenv().plrtowers = {}
getgenv().destroyui = false

getgenv().temp = {modifiers = {}, towers = {}}
getgenv().hooks = {}
getgenv().recorded_events = {}

for i = 1, #modifiers do
    temp.modifiers[i] = `'{modifiers[i]}'`
end

for i, v in equippedtowers do
    table.insert(temp.towers, `'{v}'`)
end

local window = library:CreateWindow({
    Title = "Recorder UI", -- Renamed for clarity
    Size = UDim2.new(0, 350, 0, 400),
    Position = UDim2.new(0.5, 0, 0, 70),
    NoResize = false
})

window:Center()

local modifiers_str = `\{{concat(temp.modifiers, ", ")}\}`
local plrtowers_str = `\{{concat(temp.towers, ", ")}\}`

temp = nil -- Clean up

local filetab = window:CreateTab({
    Name = "Recorder",
    Visible = true
})

local filename = filetab:Label({
    Text = "StratName: " .. getgenv().StratName
})

local textbox = filetab:InputText({
    Label = "",
    PlaceHolder = "Enter Name: ",
    Callback = function(text)
        getgenv().StratName = text.Value
        filename:SetText("StratName: " .. text.Value)
    end
})

local writebutton = filetab:Button({
    Text = "Write File",
    Callback = function()
        local content = "local api = loadstring(game:HttpGet('https://raw.githubusercontent.com/Shiro291/RTD/refs/heads/main/api'))()\n\n" ..
            `api:Loadout({plrtowers_str})\n` ..
            `api:Map('{map}', {modifiers_str})\n\n` ..
            "api:Start()\n\n" ..
            "api:Loop(function()\n"

        if #recorded_events > 0 then
            local start_time = 0
            for _, event in ipairs(recorded_events) do
                if event.time > 0 then
                    start_time = event.time
                    break
                end
            end
            
            local current_wave = -1
            
            for _, event in ipairs(recorded_events) do
                local normalized_time = math.max(0, event.time - start_time)
                normalized_time = math.floor(normalized_time * 100) / 100
                
                -- Smart Formatting: Wave Comments
                if event.wave ~= current_wave then
                    current_wave = event.wave
                    content = content .. `\n\t-- Wave {current_wave} --\n`
                end
                
                -- Construct line based on type
                if event.type == "Difficulty" then
                    content = content .. `\tapi:Difficulty('{event.args[1]}')\n`
                elseif event.type == "Place" then
                    content = content .. `\tapi:Place('{event.args[1]}', Vector3.new({event.args[2]}), {normalized_time}, {event.wave})\n`
                elseif event.type == "Upgrade" then
                    content = content .. `\tapi:Upgrade({event.args[1]}, {normalized_time}, {event.wave})\n`
                elseif event.type == "Sell" then
                    content = content .. `\tapi:Sell({event.args[1]}, {normalized_time}, {event.wave})\n`
                elseif event.type == "Target" then
                    content = content .. `\tapi:SetTarget({event.args[1]}, '{event.args[2]}', {normalized_time}, {event.wave})\n`
                elseif event.type == "Ready" then
                    content = content .. `\tapi:Ready({normalized_time}, {event.wave})\n`
                elseif event.type == "Skip" then
                    content = content .. `\tapi:Skip({normalized_time}, {event.wave})\n`
                elseif event.type == "AutoSkip" then
                    content = content .. `\tapi:AutoSkip({event.args[1]}, {normalized_time}, {event.wave})\n`
                elseif event.type == "PlayAgain" then
                    content = content .. `\tapi:PlayAgain()\n`
                end
            end
        end

        content = content .. "end)"
        
        writefile(getgenv().StratName .. '.lua', content)
        
        -- Notification
        StarterGui:SetCore("SendNotification", {
            Title = "Recorder",
            Text = "Macro saved to " .. getgenv().StratName .. ".lua",
            Duration = 5
        })
        
        getgenv().destroyui = true
    end
})

-- Minimal Mode Keybind
filetab:Keybind({
    Label = "Toggle UI",
    Value = Enum.KeyCode.RightControl, -- Default
    Callback = function()
        window:SetVisible(not window.Window.Visible)
    end
})

while not destroyui do
    taskwait(0.1)
end

writebutton:Destroy()
textbox:Destroy()
taskwait(1)

-- Logging UI
local recordertab = filetab
local logstab = window:CreateTab({
    Name = "Logs",
    Visible = true
})

local loglabel = recordertab:Label({
    Label = "Last Log: Voting"
})

local row = logstab:Row()
logstab:Separator({Text = "Logs:"})

local logs = logstab:Console({
    Text = "",
    ReadOnly = true,
    LineNumbers = false,
    Border = false,
    Fill = true,
    Enabled = true,
    MaxLines = 200
})

function updatelog(text: string)
    setthreadidentity(7)
    local timestamp = DateTime.now():FormatLocalTime("HH:mm:ss", "en-us")
    logs:AppendText(timestamp .. ":", text)
    loglabel:SetText("Last Log: " .. text)
    
    -- Notification for key events
    if text:match("Macro Recorded") or text:match("Voting") then
        StarterGui:SetCore("SendNotification", {
            Title = "Recorder",
            Text = text,
            Duration = 3
        })
    end
end

window:ShowTab(recordertab)
updatelog("Voting")

while #mapinfo:GetAttribute("Difficulty") == 0 do
    taskwait(0.05)
end 

-- Timer
local TimerConnection = RunService.Heartbeat:Connect(function(dt)
    -- Global timer for compatibility, BUT consider localized if possible
    -- We keep global because hooks might need it if they were separate functions
    -- But hooks are defined below in this scope, so we can use local upvalue `timer`!
    -- Let's stick to global for now as user requested simple upgrades, but Clean Code suggests avoiding globals.
    -- I'll use local upvalue for timer inside this script
    timer = timer + (dt * 2) 
    getgenv().timer = timer -- Sync to global just in case external debuggers use it
end)

updatelog("Game Started")

mapinfo:GetAttributeChangedSignal("Wave"):Connect(function()
    wave = mapinfo:GetAttribute("Wave")
end)

local function RecordEvent(type, args)
    table.insert(recorded_events, {
        type = type,
        args = args,
        time = timer,
        wave = wave
    })
    
    -- Subtle notification for actions? Maybe too spammy.
    -- Let's notify on major actions only?
    -- No, user just wanted notifications. Log update handles it.
end

RecordEvent("Difficulty", {mapinfo:GetAttribute("Difficulty")})

bytenet.RoundResult.Show.listen(function()
    updatelog("Macro Recorded!")
    RecordEvent("PlayAgain", {})
    if TimerConnection then TimerConnection:Disconnect() end
end)

hooks["ready"] = hookfunction(bytenet.ReadyVote.Vote.send, function(value)
    if checkcaller() then return hooks["ready"](value) end
    updatelog("Sent ready vote")
    RecordEvent("Ready", {})
    return hooks["ready"](value)
end)

hooks["skip"] = hookfunction(bytenet.SkipWave.Vote.send, function(value)
    if checkcaller() then return hooks["skip"](value) end
    updatelog("Skipped Wave " .. wave)
    RecordEvent("Skip", {})
    return hooks["skip"](value)
end)

hooks["autoskip"] = hookfunction(bytenet.SkipWave.ToggleAutoSkip.send, function(value)
    if checkcaller() then return hooks["autoskip"](value) end
    updatelog("AutoSkip: " .. tostring(value))
    RecordEvent("AutoSkip", {value})
    return hooks["autoskip"](value)
end)

hooks["place"] = hookfunction(towers.PlaceTower.invoke, function(towerdata)    
    if checkcaller() then return hooks["place"](towerdata) end
    updatelog(`Placed Tower {towerdata.TowerID}`)
    local pos = towerdata.Position
    local posStr = `{pos.X}, {pos.Y}, {pos.Z}`
    RecordEvent("Place", {towerdata.TowerID, posStr})
    return hooks["place"](towerdata)
end)

hooks["upgrade"] = hookfunction(towers.UpgradeTower.invoke, function(index)
    if checkcaller() then return hooks["upgrade"](index) end
    updatelog("Upgraded Tower " .. index)
    RecordEvent("Upgrade", {index})
    return hooks["upgrade"](index)
end)

hooks["target"] = hookfunction(towers.SetTargetMode.send, function(towerdata)
    if checkcaller() then return hooks["target"](towerdata) end
    updatelog(`Target {towerdata.UID} -> {towerdata.TargetMode}`)
    RecordEvent("Target", {towerdata.UID, towerdata.TargetMode})
    return hooks["target"](towerdata)
end)

hooks["sell"] = hookfunction(towers.SellTower.invoke, function(index)
    if checkcaller() then return hooks["sell"](index) end
    updatelog("Sold Tower " .. index)
    RecordEvent("Sell", {index})
    return hooks["sell"](index)
end)
